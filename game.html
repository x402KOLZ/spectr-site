<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>$SPECTR - SPECTR-MAN</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=VT323&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #04070d;
            --bg-panel: #0a1020;
            --light: #A0B8D8;
            --accent: #0052FF;
            --deep: #0a1a3a;
            --cream: #DDE8F5;
            --glow: #3B82F6;
            --blue: #60A5FA;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'VT323', monospace;
            background: var(--bg-dark);
            color: var(--cream);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(0deg,rgba(0,0,0,0.15),rgba(0,0,0,0.15) 1px,transparent 1px,transparent 2px);
            z-index: 1000;
        }

        header {
            padding: 20px;
            width: 100%;
            text-align: center;
        }

        .back-link {
            font-family: 'VT323', monospace;
            font-size: 1.4rem;
            color: var(--light);
            text-decoration: none;
            position: absolute;
            left: 30px;
            top: 25px;
        }
        .back-link:hover { color: var(--glow); text-shadow: 0 0 10px var(--glow); }

        .game-title {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(1rem, 4vw, 1.8rem);
            background: linear-gradient(180deg, var(--cream) 0%, var(--glow) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(2px 2px 0 var(--accent));
        }

        .game-container {
            margin-top: 20px;
            position: relative;
        }

        canvas {
            border: 3px solid var(--accent);
            box-shadow: 0 0 40px rgba(0, 82, 255, 0.3);
            display: block;
            image-rendering: pixelated;
        }

        .game-hud {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 560px;
            margin: 15px auto 0;
            padding: 0 5px;
        }

        .hud-item {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.65rem;
            color: var(--cream);
        }
        .hud-item span { color: var(--glow); }

        .game-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(4, 7, 13, 0.85);
            z-index: 10;
        }

        .game-overlay.hidden { display: none; }

        .overlay-title {
            font-family: 'Press Start 2P', cursive;
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: var(--glow);
            margin-bottom: 20px;
            text-shadow: 0 0 20px var(--accent);
        }

        .overlay-sub {
            font-size: 1.5rem;
            color: var(--light);
            margin-bottom: 30px;
        }

        .overlay-score {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8rem;
            color: var(--cream);
            margin-bottom: 20px;
        }

        .start-btn {
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7rem;
            padding: 15px 30px;
            background: var(--accent);
            color: var(--cream);
            border: none;
            cursor: pointer;
            box-shadow: 4px 4px 0 var(--deep);
            transition: all 0.2s;
        }
        .start-btn:hover {
            transform: translate(-2px, -2px);
            box-shadow: 6px 6px 0 var(--deep);
        }

        .controls-hint {
            margin-top: 15px;
            font-size: 1.3rem;
            color: var(--light);
            text-align: center;
            opacity: 0.7;
        }

        .mobile-controls {
            display: none;
            margin-top: 15px;
            gap: 5px;
        }

        .d-pad {
            display: grid;
            grid-template-areas:
                ". up ."
                "left . right"
                ". down .";
            gap: 5px;
        }

        .d-btn {
            width: 55px;
            height: 55px;
            background: var(--deep);
            border: 2px solid var(--accent);
            color: var(--cream);
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
        }
        .d-btn:active { background: var(--accent); }
        .d-up { grid-area: up; }
        .d-down { grid-area: down; }
        .d-left { grid-area: left; }
        .d-right { grid-area: right; }

        @media (max-width: 600px) {
            .mobile-controls { display: flex; justify-content: center; }
            canvas { max-width: 95vw; max-height: 60vh; }
        }
    </style>
</head>
<body>
    <header>
        <a href="index.html" class="back-link">&lt; BACK</a>
        <div class="game-title">SPECTR-MAN</div>
    </header>

    <div class="game-container">
        <canvas id="game" width="560" height="620"></canvas>

        <div class="game-overlay" id="startOverlay">
            <div class="overlay-title">SPECTR-MAN</div>
            <div class="overlay-sub">Collect $SPECTR tokens. Avoid the bugs.</div>
            <button class="start-btn" onclick="startGame()">START GAME</button>
            <div class="controls-hint">WASD / Arrow Keys to move</div>
        </div>

        <div class="game-overlay hidden" id="gameOverOverlay">
            <div class="overlay-title">GAME OVER</div>
            <div class="overlay-score" id="finalScore">SCORE: 0</div>
            <button class="start-btn" onclick="startGame()">PLAY AGAIN</button>
        </div>

        <div class="game-overlay hidden" id="winOverlay">
            <div class="overlay-title">YOU WIN!</div>
            <div class="overlay-score" id="winScore">SCORE: 0</div>
            <div class="overlay-sub">All tokens collected!</div>
            <button class="start-btn" onclick="startGame()">PLAY AGAIN</button>
        </div>
    </div>

    <div class="game-hud">
        <div class="hud-item">SCORE: <span id="scoreDisplay">0</span></div>
        <div class="hud-item">LIVES: <span id="livesDisplay">3</span></div>
        <div class="hud-item">LEVEL: <span id="levelDisplay">1</span></div>
    </div>

    <div class="mobile-controls">
        <div class="d-pad">
            <button class="d-btn d-up" ontouchstart="setDir(0,-1)" onmousedown="setDir(0,-1)">&#9650;</button>
            <button class="d-btn d-left" ontouchstart="setDir(-1,0)" onmousedown="setDir(-1,0)">&#9664;</button>
            <button class="d-btn d-right" ontouchstart="setDir(1,0)" onmousedown="setDir(1,0)">&#9654;</button>
            <button class="d-btn d-down" ontouchstart="setDir(0,1)" onmousedown="setDir(0,1)">&#9660;</button>
        </div>
    </div>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const TILE = 20;
    const COLS = 28;
    const ROWS = 31;
    canvas.width = COLS * TILE;
    canvas.height = ROWS * TILE;

    // 0=empty, 1=wall, 2=dot, 3=power pellet, 4=ghost house
    const MAP_TEMPLATE = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,3,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,3,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
        [1,2,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,1,2,1,1,1,1,1,0,1,1,0,1,1,1,1,1,2,1,0,0,0,0,0],
        [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
        [0,0,0,0,0,1,2,1,1,0,1,1,1,4,4,1,1,1,0,1,1,2,1,0,0,0,0,0],
        [1,1,1,1,1,1,2,1,1,0,1,4,4,4,4,4,4,1,0,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,0,2,0,0,0,1,4,4,4,4,4,4,1,0,0,0,2,0,0,0,0,0,0],
        [1,1,1,1,1,1,2,1,1,0,1,4,4,4,4,4,4,1,0,1,1,2,1,1,1,1,1,1],
        [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
        [0,0,0,0,0,1,2,1,1,0,0,0,0,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0],
        [0,0,0,0,0,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,0,0,0,0,0],
        [1,1,1,1,1,1,2,1,1,0,1,1,1,1,1,1,1,1,0,1,1,2,1,1,1,1,1,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,1,1,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,2,1,1,1,1,2,1,1,1,1,1,2,1,1,2,1,1,1,1,1,2,1,1,1,1,2,1],
        [1,3,2,2,1,1,2,2,2,2,2,2,2,0,0,2,2,2,2,2,2,2,1,1,2,2,3,1],
        [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
        [1,1,1,2,1,1,2,1,1,2,1,1,1,1,1,1,1,1,2,1,1,2,1,1,2,1,1,1],
        [1,2,2,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,1,1,2,2,2,2,2,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,1,1,1,1,1,1,1,1,1,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,2,1],
        [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ];

    let map, dots, score, lives, level, gameState, animFrame;
    let player, ghosts, ghostTimer, powerTimer;
    let nextDir = { x: 0, y: 0 };

    const GHOST_COLORS = ['#FF4444', '#FFB8FF', '#00FFFF', '#FFB852'];
    const GHOST_SCARED = '#2222FF';

    function resetMap() {
        map = MAP_TEMPLATE.map(r => [...r]);
        dots = 0;
        for (let r = 0; r < ROWS; r++)
            for (let c = 0; c < COLS; c++)
                if (map[r][c] === 2 || map[r][c] === 3) dots++;
    }

    function initPlayer() {
        return { x: 14, y: 23, dir: { x: 0, y: 0 }, nextDir: { x: 0, y: 0 }, mouthOpen: 0, mouthDir: 1 };
    }

    function initGhosts() {
        return [
            { x: 14, y: 11, dir: { x: 1, y: 0 }, scared: false, eaten: false, home: true, homeTimer: 0, color: GHOST_COLORS[0] },
            { x: 12, y: 14, dir: { x: -1, y: 0 }, scared: false, eaten: false, home: true, homeTimer: 60, color: GHOST_COLORS[1] },
            { x: 14, y: 14, dir: { x: 0, y: -1 }, scared: false, eaten: false, home: true, homeTimer: 120, color: GHOST_COLORS[2] },
            { x: 16, y: 14, dir: { x: 1, y: 0 }, scared: false, eaten: false, home: true, homeTimer: 180, color: GHOST_COLORS[3] },
        ];
    }

    function canMove(x, y) {
        const col = Math.round(x);
        const row = Math.round(y);
        if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return true; // tunnel wrap
        const tile = map[row][col];
        return tile !== 1;
    }

    function canMoveGhost(x, y, ghost) {
        const col = Math.round(x);
        const row = Math.round(y);
        if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return true;
        const tile = map[row][col];
        if (tile === 1) return false;
        if (tile === 4 && !ghost.home && !ghost.eaten) return false;
        return true;
    }

    function wrapPos(entity) {
        if (entity.x < -1) entity.x = COLS;
        if (entity.x > COLS) entity.x = -1;
    }

    function movePlayer() {
        const nx = player.x + player.nextDir.x;
        const ny = player.y + player.nextDir.y;
        if (canMove(nx, ny)) {
            player.dir = { ...player.nextDir };
        }

        const mx = player.x + player.dir.x;
        const my = player.y + player.dir.y;
        if (canMove(mx, my)) {
            player.x += player.dir.x * 0.15;
            player.y += player.dir.y * 0.15;

            // Snap to grid when close
            if (Math.abs(player.x - Math.round(player.x)) < 0.08) player.x = Math.round(player.x);
            if (Math.abs(player.y - Math.round(player.y)) < 0.08) player.y = Math.round(player.y);
        }
        wrapPos(player);

        // Eat dots
        const col = Math.round(player.x);
        const row = Math.round(player.y);
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            if (map[row][col] === 2) {
                map[row][col] = 0;
                score += 10;
                dots--;
                playEatSound();
            } else if (map[row][col] === 3) {
                map[row][col] = 0;
                score += 50;
                dots--;
                powerTimer = 300;
                ghosts.forEach(g => { if (!g.eaten) g.scared = true; });
                playPowerSound();
            }
        }

        // Animate mouth
        player.mouthOpen += 0.15 * player.mouthDir;
        if (player.mouthOpen > 1) { player.mouthOpen = 1; player.mouthDir = -1; }
        if (player.mouthOpen < 0) { player.mouthOpen = 0; player.mouthDir = 1; }

        if (dots <= 0) {
            gameState = 'win';
            document.getElementById('winOverlay').classList.remove('hidden');
            document.getElementById('winScore').textContent = 'SCORE: ' + score;
        }
    }

    function moveGhosts() {
        ghostTimer++;

        ghosts.forEach((g, i) => {
            if (g.home) {
                g.homeTimer--;
                if (g.homeTimer <= 0) {
                    g.home = false;
                    g.x = 14;
                    g.y = 11;
                    g.dir = { x: [-1, 1][Math.floor(Math.random() * 2)], y: 0 };
                }
                return;
            }

            const speed = g.scared ? 0.1 : 0.12;

            // Move
            g.x += g.dir.x * speed;
            g.y += g.dir.y * speed;
            wrapPos(g);

            // Snap
            if (Math.abs(g.x - Math.round(g.x)) < 0.06) g.x = Math.round(g.x);
            if (Math.abs(g.y - Math.round(g.y)) < 0.06) g.y = Math.round(g.y);

            // At grid intersection, pick new direction
            if (g.x === Math.round(g.x) && g.y === Math.round(g.y)) {
                const dirs = [
                    { x: 0, y: -1 }, { x: 0, y: 1 },
                    { x: -1, y: 0 }, { x: 1, y: 0 }
                ];
                const reverse = { x: -g.dir.x, y: -g.dir.y };
                const valid = dirs.filter(d => {
                    if (d.x === reverse.x && d.y === reverse.y) return false;
                    return canMoveGhost(g.x + d.x, g.y + d.y, g);
                });

                if (valid.length > 0) {
                    if (g.scared || Math.random() < 0.3) {
                        // Random when scared or sometimes random
                        g.dir = valid[Math.floor(Math.random() * valid.length)];
                    } else {
                        // Chase player
                        let bestDist = Infinity;
                        let bestDir = valid[0];
                        valid.forEach(d => {
                            const nx = g.x + d.x;
                            const ny = g.y + d.y;
                            const dist = Math.abs(nx - player.x) + Math.abs(ny - player.y);
                            if (dist < bestDist) { bestDist = dist; bestDir = d; }
                        });
                        g.dir = bestDir;
                    }
                } else {
                    // Dead end, reverse
                    g.dir = reverse;
                }
            }
        });

        // Power timer
        if (powerTimer > 0) {
            powerTimer--;
            if (powerTimer <= 0) {
                ghosts.forEach(g => g.scared = false);
            }
        }

        // Collision check
        ghosts.forEach(g => {
            if (g.home || g.eaten) return;
            const dist = Math.abs(g.x - player.x) + Math.abs(g.y - player.y);
            if (dist < 0.8) {
                if (g.scared) {
                    g.eaten = true;
                    g.scared = false;
                    g.home = true;
                    g.homeTimer = 120;
                    g.x = 14; g.y = 14;
                    score += 200;
                    playEatGhostSound();
                } else {
                    loseLife();
                }
            }
        });
    }

    function loseLife() {
        lives--;
        if (lives <= 0) {
            gameState = 'gameover';
            document.getElementById('gameOverOverlay').classList.remove('hidden');
            document.getElementById('finalScore').textContent = 'SCORE: ' + score;
            playDeathSound();
        } else {
            player = initPlayer();
            ghosts = initGhosts();
            playDeathSound();
        }
    }

    // Simple audio via Web Audio API
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playTone(freq, duration, type = 'square') {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = 0.08;
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    function playEatSound() { playTone(600, 0.05); setTimeout(() => playTone(800, 0.05), 50); }
    function playPowerSound() { playTone(200, 0.2, 'sawtooth'); setTimeout(() => playTone(400, 0.3, 'sawtooth'), 100); }
    function playEatGhostSound() { playTone(300, 0.1); setTimeout(() => playTone(600, 0.1), 80); setTimeout(() => playTone(900, 0.15), 160); }
    function playDeathSound() { playTone(400, 0.15); setTimeout(() => playTone(300, 0.15), 150); setTimeout(() => playTone(200, 0.3), 300); }

    function drawMap() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                const x = c * TILE;
                const y = r * TILE;
                const tile = map[r][c];

                if (tile === 1) {
                    ctx.fillStyle = '#0a1a3a';
                    ctx.fillRect(x, y, TILE, TILE);
                    // Draw wall borders
                    ctx.strokeStyle = '#0052FF';
                    ctx.lineWidth = 1.5;
                    // Only draw edges adjacent to non-wall
                    if (r > 0 && map[r-1][c] !== 1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + TILE, y); ctx.stroke(); }
                    if (r < ROWS-1 && map[r+1][c] !== 1) { ctx.beginPath(); ctx.moveTo(x, y + TILE); ctx.lineTo(x + TILE, y + TILE); ctx.stroke(); }
                    if (c > 0 && map[r][c-1] !== 1) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + TILE); ctx.stroke(); }
                    if (c < COLS-1 && map[r][c+1] !== 1) { ctx.beginPath(); ctx.moveTo(x + TILE, y); ctx.lineTo(x + TILE, y + TILE); ctx.stroke(); }
                } else {
                    ctx.fillStyle = '#04070d';
                    ctx.fillRect(x, y, TILE, TILE);
                }

                if (tile === 2) {
                    // Token dot - small blue circle
                    ctx.fillStyle = '#3B82F6';
                    ctx.beginPath();
                    ctx.arc(x + TILE/2, y + TILE/2, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (tile === 3) {
                    // Power pellet - larger pulsing glow
                    const pulse = 0.7 + Math.sin(Date.now() / 200) * 0.3;
                    ctx.fillStyle = `rgba(96, 165, 250, ${pulse})`;
                    ctx.shadowColor = '#60A5FA';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(x + TILE/2, y + TILE/2, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }
    }

    function drawPlayer() {
        const x = player.x * TILE + TILE/2;
        const y = player.y * TILE + TILE/2;
        const r = TILE/2 - 2;
        const mouthAngle = player.mouthOpen * 0.8;

        // Direction angle
        let angle = 0;
        if (player.dir.x === 1) angle = 0;
        else if (player.dir.x === -1) angle = Math.PI;
        else if (player.dir.y === -1) angle = -Math.PI/2;
        else if (player.dir.y === 1) angle = Math.PI/2;

        // Glow
        ctx.shadowColor = '#0052FF';
        ctx.shadowBlur = 12;

        // Body
        ctx.fillStyle = '#0052FF';
        ctx.beginPath();
        ctx.arc(x, y, r, angle + mouthAngle, angle + Math.PI * 2 - mouthAngle);
        ctx.lineTo(x, y);
        ctx.fill();

        // Eye
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#DDE8F5';
        const eyeX = x + Math.cos(angle - 0.5) * (r * 0.4);
        const eyeY = y + Math.sin(angle - 0.5) * (r * 0.4);
        ctx.beginPath();
        ctx.arc(eyeX, eyeY, 2, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawGhosts() {
        ghosts.forEach(g => {
            if (g.home && g.homeTimer > 0) return;
            const x = g.x * TILE + TILE/2;
            const y = g.y * TILE + TILE/2;
            const r = TILE/2 - 2;

            let color = g.color;
            if (g.scared) {
                color = powerTimer < 80 && Math.floor(Date.now() / 150) % 2 ? '#FFFFFF' : GHOST_SCARED;
            }

            // Body
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x, y - 2, r, Math.PI, 0);
            ctx.lineTo(x + r, y + r);
            // Wavy bottom
            for (let i = 0; i < 4; i++) {
                const wx = x + r - (i * r / 2);
                const wy = y + r - (i % 2 ? 3 : 0);
                ctx.lineTo(wx, wy);
            }
            ctx.lineTo(x - r, y + r);
            ctx.closePath();
            ctx.fill();

            // Eyes
            if (!g.scared) {
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(x - 3, y - 3, 3, 0, Math.PI * 2);
                ctx.arc(x + 3, y - 3, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#222';
                const edx = g.dir.x * 1.5;
                const edy = g.dir.y * 1.5;
                ctx.beginPath();
                ctx.arc(x - 3 + edx, y - 3 + edy, 1.5, 0, Math.PI * 2);
                ctx.arc(x + 3 + edx, y - 3 + edy, 1.5, 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Scared face
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(x - 3, y - 3, 2, 0, Math.PI * 2);
                ctx.arc(x + 3, y - 3, 2, 0, Math.PI * 2);
                ctx.fill();
                // Wobbly mouth
                ctx.strokeStyle = '#FFF';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x - 5, y + 3);
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(x - 5 + i * 2.5, y + 3 + (i % 2 ? -2 : 2));
                }
                ctx.stroke();
            }
        });
    }

    function updateHUD() {
        document.getElementById('scoreDisplay').textContent = score;
        document.getElementById('livesDisplay').textContent = lives;
        document.getElementById('levelDisplay').textContent = level;
    }

    function gameLoop() {
        if (gameState !== 'playing') return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#04070d';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawMap();
        movePlayer();
        moveGhosts();
        drawPlayer();
        drawGhosts();
        updateHUD();

        animFrame = requestAnimationFrame(gameLoop);
    }

    function startGame() {
        document.getElementById('startOverlay').classList.add('hidden');
        document.getElementById('gameOverOverlay').classList.add('hidden');
        document.getElementById('winOverlay').classList.add('hidden');

        resetMap();
        player = initPlayer();
        ghosts = initGhosts();
        score = 0;
        lives = 3;
        level = 1;
        ghostTimer = 0;
        powerTimer = 0;
        gameState = 'playing';

        if (audioCtx.state === 'suspended') audioCtx.resume();
        if (animFrame) cancelAnimationFrame(animFrame);
        gameLoop();
    }

    function setDir(x, y) {
        if (gameState === 'playing') {
            player.nextDir = { x, y };
        }
    }

    // Keyboard
    document.addEventListener('keydown', (e) => {
        switch (e.key) {
            case 'ArrowUp': case 'w': case 'W': setDir(0, -1); e.preventDefault(); break;
            case 'ArrowDown': case 's': case 'S': setDir(0, 1); e.preventDefault(); break;
            case 'ArrowLeft': case 'a': case 'A': setDir(-1, 0); e.preventDefault(); break;
            case 'ArrowRight': case 'd': case 'D': setDir(1, 0); e.preventDefault(); break;
        }
    });

    // Draw initial screen
    ctx.fillStyle = '#04070d';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    resetMap();
    drawMap();
    </script>
</body>
</html>
